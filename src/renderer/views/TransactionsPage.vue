<template>
  <the-table-page-view
    :view="tablePageView"
    :get-item-creation-template-model="getItemCreationTemplateModel"
  >
    <template
      slot="creation-form-addon"
      slot-scope="{ model }"
    >
      <div
        class="formAddon__message"
        v-text="creationFormAddonMessage"
      />
    </template>

    <template
      slot="editing-form-addon"
      slot-scope="{ model }"
    >
      <div
        class="formAddon__message"
        v-text="editingFormAddonMessage"
      />
    </template>
  </the-table-page-view>
</template>

<script>
import _ from 'lodash'
import { mapGetters } from 'vuex'

import {
  QUERY_PARAM_ID,
} from '@/router/table-view-constants'
import { KomodTransaction } from '@/types/KomodTransaction'
import { stringifyKomodClient } from '@/types/KomodClient'
import TheTablePageView from '@/components/TheTablePageView'
import EventBus from '@/EventBus'
import {
  isDateInCurrentSeason,
  defaultDatetimeTableFormatter,
  repeatedDayDatetimeTableFormatter,
} from '@/utils/date'
import {
  requiredFieldMessage,
  takenItemsExcessMessage,
} from '@/utils/validation'
import { ROUTE_NAME_TRANSACTIONS } from '@/router'

export default {
  name: 'TransactionsPage',

  components: {
    TheTablePageView,
  },

  /**
   * @return {{tablePageView: ITablePageView}}
   */
  data () {
    const self = this

    const clientIdRefFormatter = (client) => {
      // Добавить в лейбл в контроле номер удостоверения,
      // в том числе для возможности поиска в выпадающем списке по нему
      const idDocPostfix = client && client.idDocument
        ? ` (уд. ${client.idDocument})`
        : ''

      return stringifyKomodClient(client) + idDocPostfix
    }

    return {
      tablePageView: {
        storeModuleName: 'transactions',
        routeName: ROUTE_NAME_TRANSACTIONS,

        hideIndex: true,

        defaultSort: {
          prop: 'date',
          order: 'descending',
        },

        itemBaseProperties: [
          {
            name: 'date',
            label: 'Дата',
            type: 'datetime',
            tableFormatter: ({ value, elUiCellScope, fieldView }) => {
              // Для визуальной "группировки" строк одного и того же дня
              // выводим полную дату только для строки, в которой день
              // встречается первый раз на странице.
              // Т.е. для первой строки, и для строк, день даты которых
              // отличается от дня даты предыдущей строки.
              // Для остальных выводим только время, отступая пробелами
              // на ширину дневной части даты.

              if (elUiCellScope.$index === 0) {
                return defaultDatetimeTableFormatter(value)
              }

              if (elUiCellScope.$index > 0) {
                const prevRowDate = new Date(
                  elUiCellScope.store.states.data[elUiCellScope.$index - 1][fieldView.name]
                )
                const curRowDate = new Date(value)

                if (curRowDate.toDateString() !== prevRowDate.toDateString()) {
                  return defaultDatetimeTableFormatter(value)
                }
              }

              return repeatedDayDatetimeTableFormatter(value)
            },
            validationRules: [
              {
                required: true,
                trigger: ['blur', 'change'],
                message: requiredFieldMessage,
              },
            ],
            sortable: true,
            filterable: true,
          },
          {
            name: 'clientId',
            label: 'Клиент',
            type: 'ref',
            get optionsArr () {
              const clients = Object.values(self.clientsMap)
                .map(client => ({
                  key: client.id,
                  value: client.id,
                  label: clientIdRefFormatter(client),
                }))
                .sort((a, b) => a.label > b.label ? 1 : -1)

              return clients
            },
            // Для `optionsArr` не используется
            controlFormatter: clientIdRefFormatter,
            tableFormatter: ({ value }) => {
              return stringifyKomodClient(this.clientsMap[value])
            },
            hrefModuleName: 'clients',
            hrefQueryIdParam: QUERY_PARAM_ID,
            filterable: true,
            validationRules: [
              {
                required: true,
                trigger: ['blur', 'change'],
                message: requiredFieldMessage,
              },
            ],
            // При изменении клиента нужно перевалидировать поле "Кол-во вещей",
            // т.к. остаток от лимита у этого клиента может быть другой
            triggerRevalidation: true,

            // TODO раскостылить
            addCreateClientHackButton: true,
          },
          {
            name: 'itemsAmount',
            label: 'Кол-во вещей',
            type: 'number',
            min: 0,
            validationRules: [
              {
                validator (rule, fieldValue, callback, formModel) {
                  const seasonInfo = self.getClientSeasonItemsInfo(
                    formModel.clientId,
                    // При редактировании транзакции имеющееся "Взятое кол-во"
                    // не должно учитываться во взятом за сезон
                    formModel.id,
                  )

                  if (fieldValue > seasonInfo.remaining) {
                    callback(new Error(takenItemsExcessMessage))
                  } else {
                    callback()
                  }
                },
                trigger: ['blur', 'change'],
              },
            ],
            sortable: true,
          },
          {
            name: 'comment',
            label: 'Комментарий',
            type: 'string',
            minWidth: 100,
            filterable: true,
          },
        ],

        itemComputedTableProperties: [],
      },

      globalEventHandlers: {
        'form-change': this.handleItemFormChange.bind(this),
      },

      creationFormAddonMessage: '',
      editingFormAddonMessage: '',
    }
  },

  computed: {
    ...mapGetters({
      clientsMap: 'clients/itemsMap',
      transactionsMap: 'transactions/itemsMap',
      currentSeasonItemsAmountByClient: 'transactions/currentSeasonItemsAmountByClient',
    }),
  },

  created () {
    _.forEach(this.globalEventHandlers, (handler, event) => {
      EventBus.$on(event, handler)
    })
  },

  beforeDestroy () {
    _.forEach(this.globalEventHandlers, (handler, event) => {
      EventBus.$off(event, handler)
    })
  },

  methods: {
    getItemCreationTemplateModel () {
      return new KomodTransaction()
    },

    handleItemFormChange ({ formName, model }) {
      // Add message to the form about how many items
      // current transaction can have based on client's limit and history
      if (formName === `${this.tablePageView.storeModuleName}/creation`) {
        // Client is unset or not yet set
        if (!model.clientId) {
          this.creationFormAddonMessage = ''

          return
        }

        const seasonInfo = this.getClientSeasonItemsInfo(model.clientId, model.id)

        this.creationFormAddonMessage =
          `У выбранного клиента осталось ${seasonInfo.remaining} вещей из ${seasonInfo.limit}`
      } else if (formName === `${this.tablePageView.storeModuleName}/editing`) {
        // Client is unset or not yet set
        if (!model.clientId) {
          this.editingFormAddonMessage = ''

          return
        }

        if (model.clientId && !this.clientsMap[model.clientId]) {
          this.editingFormAddonMessage = 'Выбранный клиент был удален из базы данных'

          return
        }

        const seasonInfo = this.getClientSeasonItemsInfo(model.clientId, model.id)

        this.editingFormAddonMessage =
          `У выбранного клиента осталось ${seasonInfo.remaining} вещей из ${seasonInfo.limit}`
      }
    },

    /**
     * @param {string} clientId
     * @param {string =} editedTransactionId
     * @return {{limit: number, remaining: number}}
     */
    getClientSeasonItemsInfo (clientId, editedTransactionId) {
      const limit = this.clientsMap[clientId]
        ? this.clientsMap[clientId].seasonItemsLimit
        : 0

      let taken = this.currentSeasonItemsAmountByClient[clientId] || 0

      // При редактировании существующей транзакции текущго сезона,
      // её `itemsAmount` включается во "взятое кол-во".
      // Для UI и валидации, схожими с созданием транзакции,
      // сделаем "Осталось" без учета текущего значения
      if (editedTransactionId) {
        const editedTransaction = this.transactionsMap[editedTransactionId]

        if (editedTransaction && isDateInCurrentSeason(editedTransaction.date)) {
          taken -= editedTransaction.itemsAmount
        }
      }

      return {
        limit,
        remaining: limit - taken,
      }
    },
  },
}
</script>

<style scoped>
  .formAddon__message {
    text-align: center;
    margin-bottom: 20px;
  }
</style>
